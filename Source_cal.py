#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Forward-pushed particle analysis and sky-map construction (4-beam case i.e. 4 sources).

Overview
--------
- Reads particle trajectories (initial/final momenta) from a CSV that was
  **generated by combining outputs from `Forward_pushing_particles.py`**.
- Samples random initial dipole directions and selects particles within a
  generalized-normal angular window.
- Builds CRPropa ParticleMaps for injected and received directions.
- Rotates maps so that four specific target directions (Centaurus A, NGC 253,
  M31, M82) align with the sampled dipole direction and accumulates results.
- Writes resulting HEALPix maps to FITS.

Notes
-----
- This is a minimal conversion from a Jupyter notebook: no CLI args added,
  no refactors beyond comments/docstrings and Jupyter cleanup.
- Requires: numpy, pandas, healpy, crpropa.
"""

import time
import numpy as np
import pandas as pd
import healpy as hp

# CRPropa imports (kept as in your original)
import crpropa
from crpropa import *

# SciPy (stats for generalized normal distribution)
import scipy.stats as stats

# Optional: suppress warnings to keep logs clean (preserved from original)
import warnings
warnings.filterwarnings("ignore")

# Matplotlib only used here to set a font-size; plots are not produced below.
import matplotlib
matplotlib.rcParams.update({"font.size": 35})

# Convenience aliases
sqrt = np.sqrt
pi = np.pi


# -----------------------------------------------------------------------------
# Spherical-harmonic utilities (as in your notebook; used by LoadSmoothedMap)
# -----------------------------------------------------------------------------
def top_hat_beam(radius: float, lmax: int):
    """
    Build the spherical-harmonic window (b_l) for a top-hat beam.

    Parameters
    ----------
    radius : float
        Angular radius (radians) of the top-hat beam.
    lmax : int
        Maximum multipole for the beam window.

    Returns
    -------
    np.ndarray
        b_l coefficients up to lmax.

    Notes
    -----
    Uses the length of `lats_arr` to define a theta grid for `beam2bl`.
    This mirrors the original notebook behaviour.
    """
    b = np.linspace(0.0, np.pi, len(lats_arr))
    bw = np.where(abs(b) <= radius, 1, 0)
    # Beam in spherical-harmonic space
    return hp.sphtfunc.beam2bl(bw, b, lmax=lmax)


def LoadSmoothedMap(hp_map: np.ndarray, radius_deg: float, nside: int):
    """
    Smooth a HEALPix map with a top-hat beam of given angular radius.

    Parameters
    ----------
    hp_map : np.ndarray
        Input HEALPix map.
    radius_deg : float
        Top-hat beam radius (degrees).
    nside : int
        HEALPix nside. (Here, passed into `top_hat_beam` as lmax for parity.)

    Returns
    -------
    np.ndarray
        Smoothed map divided by the beam solid angle.
    """
    radius = np.radians(radius_deg)
    solid_angle = 2.0 * np.pi * (1.0 - np.cos(radius))
    return hp.smoothing(hp_map, beam_window=top_hat_beam(radius, nside), verbose=False) / solid_angle


def calcDA(m: np.ndarray):
    """
    Fit a dipole to a map and compute the dipole-to-monopole amplitude ratio.

    Parameters
    ----------
    m : np.ndarray
        HEALPix map.

    Returns
    -------
    tuple
        (monopole_amplitude, dipole_over_monopole)
    """
    dipole = hp.fit_dipole(m)
    mono_amp = dipole[0]
    DA = np.sqrt(np.sum(dipole[1] * dipole[1])) / mono_amp
    return mono_amp, DA


def rotate_vector(vector: np.ndarray, axis: np.ndarray, angle: float) -> np.ndarray:
    """
    Rotate a vector around an arbitrary axis by a given angle (Rodrigues' formula).

    Parameters
    ----------
    vector : np.ndarray
        Vector to rotate, shape (3,).
    axis : np.ndarray
        Rotation axis, shape (3,).
    angle : float
        Rotation angle in radians.

    Returns
    -------
    np.ndarray
        Rotated vector (3,).
    """
    axis = axis / np.linalg.norm(axis)
    cos_theta = np.cos(angle)
    sin_theta = np.sin(angle)
    one_minus = 1.0 - cos_theta

    x, y, z = axis
    rot = np.array(
        [
            [cos_theta + x * x * one_minus, x * y * one_minus - z * sin_theta, x * z * one_minus + y * sin_theta],
            [y * x * one_minus + z * sin_theta, cos_theta + y * y * one_minus, y * z * one_minus - x * sin_theta],
            [z * x * one_minus - y * sin_theta, z * y * one_minus + x * sin_theta, cos_theta + z * z * one_minus],
        ]
    )
    return rot @ vector


# -----------------------------------------------------------------------------
# (Preserved) math background from the notebook as comments
# -----------------------------------------------------------------------------
# Δf(θ,φ) = Σ_l Σ_m a_{l,m} Y_{l,m}(θ,φ)
# C_l = (1/(2l+1)) Σ_m a_{l,m}^2
# <Δf(θ,φ)^2> = (1/4π) Σ_l (2l+1) C_l
# δ_rms^{l=0} = sqrt(C_0 / 4π), δ_rms^{l=1} = sqrt(3 C_1 / 4π), δ_rms^{l=2} = sqrt(5 C_2 / 4π)
# Δ = δ_rms^{l=1} / δ_rms^{l=0},  Q = δ_rms^{l=2} / δ_rms^{l=0}


# -----------------------------------------------------------------------------
# Data I/O
# -----------------------------------------------------------------------------

# NOTE (provenance): The CSV below was generated by combining outputs from the
# `Forward_pushing_particles.py` script.
# If you change the filename/path, keep this provenance note in your repo.
# data_hdf = pd.read_csv('Particles_7.7.csv')
data_hdf = pd.read_csv("Particles_7.7_Rin_30_Rout_Rin_plus_1.csv")

com_data_np = data_hdf.to_numpy()
data_len = len(com_data_np)

# -----------------------------------------------------------------------------
# Generalized normal (gennorm) sampling for angular cut
# -----------------------------------------------------------------------------
beta = 2      # shape parameter
loc = 0       # location parameter
scale = 10    # scale parameter

num_samples = data_len
samples = stats.gennorm.rvs(beta, loc=loc, scale=scale, size=num_samples)

# Angles for selection (degrees -> here we keep in the 'samples' variable directly)
angles_gen_norm = samples

# -----------------------------------------------------------------------------
# Random dipole directions / setup
# -----------------------------------------------------------------------------
seed = 3              # left unused in original; keeping for parity
np.random.seed()      # keep original randomness

ang_len = 80          # number of random dipole directions to sample

# Random longitudes in [-180, 180] deg (radians)
ran_lon_arr = np.random.uniform(np.deg2rad(-180), np.deg2rad(180), ang_len)
# Uniform sin(latitude) in [-1, 1] for isotropic directions
sin_ini_lats = np.random.uniform(-1, 1, ang_len)
ran_lat_arr = np.arcsin(sin_ini_lats)

rad = np.radians
lats_arr = np.zeros(len(com_data_np))  # used by top_hat_beam (as in original)

# CRPropa particle definition
pid = -crpropa.nucleusId(1, 1)   # match original sign choice
meanEnergy = 8.5 * EeV           # 8.5 EeV mono-energetic injection

# Accumulators for maps
combined_map_inj, combined_map_rec = 0, 0

Rot_combined_map_inj, Rot_combined_map_rec = 0, 0
Rot_map_inj_1, Rot_map_inj_2, Rot_map_inj_3, Rot_map_inj_4 = 0, 0, 0, 0
Rot_map_rec_1, Rot_map_rec_2, Rot_map_rec_3, Rot_map_rec_4 = 0, 0, 0, 0

particles_dip = 0

# -----------------------------------------------------------------------------
# Main loop over random dipole directions
# -----------------------------------------------------------------------------
for j in range(0, ang_len):
    # Current dipole direction (unit vector) from sampled (lon, lat)
    dx_dip = np.cos(ran_lat_arr[j]) * np.cos(ran_lon_arr[j])
    dy_dip = np.cos(ran_lat_arr[j]) * np.sin(ran_lon_arr[j])
    dz_dip = np.sin(ran_lat_arr[j])

    print(
        "Initial dipole angle lat = ",
        np.rad2deg(ran_lat_arr[j]),
        " lon = ",
        np.rad2deg(ran_lon_arr[j]),
    )

    # Containers for this dipole orientation
    M_dip_dip = crpropa.ParticleMapsContainer()
    M_iso_injected = crpropa.ParticleMapsContainer()

    Rot_M_dip_dip_1, Rot_M_iso_injected_1 = crpropa.ParticleMapsContainer(), crpropa.ParticleMapsContainer()
    Rot_M_dip_dip_2, Rot_M_iso_injected_2 = crpropa.ParticleMapsContainer(), crpropa.ParticleMapsContainer()
    Rot_M_dip_dip_3, Rot_M_iso_injected_3 = crpropa.ParticleMapsContainer(), crpropa.ParticleMapsContainer()
    Rot_M_dip_dip_4, Rot_M_iso_injected_4 = crpropa.ParticleMapsContainer(), crpropa.ParticleMapsContainer()

    # Loop over all particles (initial/final momenta from CSV)
    for i in range(data_len):
        # Initial momentum components
        pxi = float(data_hdf["P0x"][i])
        pyi = float(data_hdf["P0y"][i])
        pzi = float(data_hdf["P0z"][i])

        # Final momentum components
        pxf = float(data_hdf["Px"][i])
        pyf = float(data_hdf["Py"][i])
        pzf = float(data_hdf["Pz"][i])

        # Convert to Galactic angles (initial)
        galactic_longitude_ini = np.arctan2(-pyi, -pxi) - pi
        galactic_latitude_ini = pi / 2 - np.arccos(pzi / np.sqrt(pxi * pxi + pyi * pyi + pzi * pzi))

        # Convert to Galactic angles (final)
        galactic_longitude = np.arctan2(-pyf, -pxf) - pi
        galactic_latitude = pi / 2 - np.arccos(pzf / np.sqrt(pxf * pxf + pyf * pyf + pzf * pzf))

        # Angle between initial momentum and current dipole direction
        angle = np.arccos(
            (pxi * dx_dip + pyi * dy_dip + pzi * dz_dip)
            / (np.sqrt(pxi**2 + pyi**2 + pzi**2) * np.sqrt(dx_dip**2 + dy_dip**2 + dz_dip**2))
        )

        # Select if within generalized-normal angular window (absolute degrees)
        if np.degrees(angle) < abs(angles_gen_norm[i]):
            particles_dip += 1

            # Add directions to maps (injected vs received)
            M_iso_injected.addParticle(pid, meanEnergy, galactic_longitude_ini, galactic_latitude_ini)
            M_dip_dip.addParticle(pid, meanEnergy, galactic_longitude, galactic_latitude)

            # -----------------------------------------------------------------
            # Rotations to align with specific sources
            # Each block: define target (l_fin, b_fin) and rotate vectors
            # -----------------------------------------------------------------

            # 1) Centaurus A
            l_fin = np.deg2rad(309.52)
            b_fin = np.deg2rad(19.42)
            l_ini, b_ini = ran_lon_arr[j], ran_lat_arr[j]

            x_ini, y_ini, z_ini = np.cos(l_ini) * np.cos(b_ini), np.cos(b_ini) * np.sin(l_ini), np.sin(b_ini)
            x_fin, y_fin, z_fin = np.cos(l_fin) * np.cos(b_fin), np.cos(b_fin) * np.sin(l_fin), np.sin(b_fin)

            axis = np.cross(np.array([x_ini, y_ini, z_ini]), np.array([x_fin, y_fin, z_fin]))
            rot_ang = np.arccos(np.dot(np.array([x_ini, y_ini, z_ini]), np.array([x_fin, y_fin, z_fin])))

            rotation_ini = rotate_vector(np.array([pxi, pyi, pzi]), axis, rot_ang)
            new_gal_lon_ini = np.arctan2(-rotation_ini[1], -rotation_ini[0]) - pi
            new_gal_lat_ini = pi / 2 - np.arccos(rotation_ini[2] / np.sqrt(np.sum(rotation_ini**2)))

            rotation_fin = rotate_vector(np.array([pxf, pyf, pzf]), axis, rot_ang)
            new_gal_lon_fin = np.arctan2(-rotation_fin[1], -rotation_fin[0]) - pi
            new_gal_lat_fin = pi / 2 - np.arccos(rotation_fin[2] / np.sqrt(np.sum(rotation_fin**2)))

            Rot_M_iso_injected_1.addParticle(pid, meanEnergy, new_gal_lon_ini, new_gal_lat_ini)
            Rot_M_dip_dip_1.addParticle(pid, meanEnergy, new_gal_lon_fin, new_gal_lat_fin)

            # 2) NGC 253
            l_fin = np.deg2rad(89.0)
            b_fin = np.deg2rad(-89.0)
            l_ini, b_ini = ran_lon_arr[j], ran_lat_arr[j]

            x_ini, y_ini, z_ini = np.cos(l_ini) * np.cos(b_ini), np.cos(b_ini) * np.sin(l_ini), np.sin(b_ini)
            x_fin, y_fin, z_fin = np.cos(l_fin) * np.cos(b_fin), np.cos(b_fin) * np.sin(l_fin), np.sin(b_fin)

            axis = np.cross(np.array([x_ini, y_ini, z_ini]), np.array([x_fin, y_fin, z_fin]))
            rot_ang = np.arccos(np.dot(np.array([x_ini, y_ini, z_ini]), np.array([x_fin, y_fin, z_fin])))

            rotation_ini = rotate_vector(np.array([pxi, pyi, pzi]), axis, rot_ang)
            new_gal_lon_ini = np.arctan2(-rotation_ini[1], -rotation_ini[0]) - pi
            new_gal_lat_ini = pi / 2 - np.arccos(rotation_ini[2] / np.sqrt(np.sum(rotation_ini**2)))

            rotation_fin = rotate_vector(np.array([pxf, pyf, pzf]), axis, rot_ang)
            new_gal_lon_fin = np.arctan2(-rotation_fin[1], -rotation_fin[0]) - pi
            new_gal_lat_fin = pi / 2 - np.arccos(rotation_fin[2] / np.sqrt(np.sum(rotation_fin**2)))

            Rot_M_iso_injected_2.addParticle(pid, meanEnergy, new_gal_lon_ini, new_gal_lat_ini)
            Rot_M_dip_dip_2.addParticle(pid, meanEnergy, new_gal_lon_fin, new_gal_lat_fin)

            # 3) M31
            l_fin = np.deg2rad(121.0)
            b_fin = np.deg2rad(-21.0)
            l_ini, b_ini = ran_lon_arr[j], ran_lat_arr[j]

            x_ini, y_ini, z_ini = np.cos(l_ini) * np.cos(b_ini), np.cos(b_ini) * np.sin(l_ini), np.sin(b_ini)
            x_fin, y_fin, z_fin = np.cos(l_fin) * np.cos(b_fin), np.cos(b_fin) * np.sin(l_fin), np.sin(b_fin)

            axis = np.cross(np.array([x_ini, y_ini, z_ini]), np.array([x_fin, y_fin, z_fin]))
            rot_ang = np.arccos(np.dot(np.array([x_ini, y_ini, z_ini]), np.array([x_fin, y_fin, z_fin])))

            rotation_ini = rotate_vector(np.array([pxi, pyi, pzi]), axis, rot_ang)
            new_gal_lon_ini = np.arctan2(-rotation_ini[1], -rotation_ini[0]) - pi
            new_gal_lat_ini = pi / 2 - np.arccos(rotation_ini[2] / np.sqrt(np.sum(rotation_ini**2)))

            rotation_fin = rotate_vector(np.array([pxf, pyf, pzf]), axis, rot_ang)
            new_gal_lon_fin = np.arctan2(-rotation_fin[1], -rotation_fin[0]) - pi
            new_gal_lat_fin = pi / 2 - np.arccos(rotation_fin[2] / np.sqrt(np.sum(rotation_fin**2)))

            Rot_M_iso_injected_3.addParticle(pid, meanEnergy, new_gal_lon_ini, new_gal_lat_ini)
            Rot_M_dip_dip_3.addParticle(pid, meanEnergy, new_gal_lon_fin, new_gal_lat_fin)

            # 4) M82
            l_fin = np.deg2rad(141.41)
            b_fin = np.deg2rad(40.57)
            l_ini, b_ini = ran_lon_arr[j], ran_lat_arr[j]

            x_ini, y_ini, z_ini = np.cos(l_ini) * np.cos(b_ini), np.cos(b_ini) * np.sin(l_ini), np.sin(b_ini)
            x_fin, y_fin, z_fin = np.cos(l_fin) * np.cos(b_fin), np.cos(b_fin) * np.sin(l_fin), np.sin(b_fin)

            axis = np.cross(np.array([x_ini, y_ini, z_ini]), np.array([x_fin, y_fin, z_fin]))
            rot_ang = np.arccos(np.dot(np.array([x_ini, y_ini, z_ini]), np.array([x_fin, y_fin, z_fin])))

            rotation_ini = rotate_vector(np.array([pxi, pyi, pzi]), axis, rot_ang)
            new_gal_lon_ini = np.arctan2(-rotation_ini[1], -rotation_ini[0]) - pi
            new_gal_lat_ini = pi / 2 - np.arccos(rotation_ini[2] / np.sqrt(np.sum(rotation_ini**2)))

            rotation_fin = rotate_vector(np.array([pxf, pyf, pzf]), axis, rot_ang)
            new_gal_lon_fin = np.arctan2(-rotation_fin[1], -rotation_fin[0]) - pi
            new_gal_lat_fin = pi / 2 - np.arccos(rotation_fin[2] / np.sqrt(np.sum(rotation_fin**2)))

            Rot_M_iso_injected_4.addParticle(pid, meanEnergy, new_gal_lon_ini, new_gal_lat_ini)
            Rot_M_dip_dip_4.addParticle(pid, meanEnergy, new_gal_lon_fin, new_gal_lat_fin)

    # Accumulate maps over this dipole orientation
    combined_map_inj += M_iso_injected.getMap(int(pid), meanEnergy)
    combined_map_rec += M_dip_dip.getMap(int(pid), meanEnergy)

    Rot_map_inj_1 += Rot_M_iso_injected_1.getMap(int(pid), meanEnergy)
    Rot_map_rec_1 += Rot_M_dip_dip_1.getMap(int(pid), meanEnergy)

    Rot_map_inj_2 += Rot_M_iso_injected_2.getMap(int(pid), meanEnergy)
    Rot_map_rec_2 += Rot_M_dip_dip_2.getMap(int(pid), meanEnergy)

    Rot_map_inj_3 += Rot_M_iso_injected_3.getMap(int(pid), meanEnergy)
    Rot_map_rec_3 += Rot_M_dip_dip_3.getMap(int(pid), meanEnergy)

    Rot_map_inj_4 += Rot_M_iso_injected_4.getMap(int(pid), meanEnergy)
    Rot_map_rec_4 += Rot_M_dip_dip_4.getMap(int(pid), meanEnergy)

    Rot_combined_map_inj += Rot_M_iso_injected_1.getMap(int(pid), meanEnergy)
    Rot_combined_map_rec += Rot_M_dip_dip_1.getMap(int(pid), meanEnergy)

    Rot_combined_map_inj += Rot_M_iso_injected_2.getMap(int(pid), meanEnergy)
    Rot_combined_map_rec += Rot_M_dip_dip_2.getMap(int(pid), meanEnergy)

    Rot_combined_map_inj += Rot_M_iso_injected_3.getMap(int(pid), meanEnergy)
    Rot_combined_map_rec += Rot_M_dip_dip_3.getMap(int(pid), meanEnergy)

    Rot_combined_map_inj += Rot_M_iso_injected_4.getMap(int(pid), meanEnergy)
    Rot_combined_map_rec += Rot_M_dip_dip_4.getMap(int(pid), meanEnergy)


print("total_num_particles = ", particles_dip)

# Optional sanity check (kept as in original)
sum(Rot_combined_map_inj), sum(Rot_combined_map_rec), sum(combined_map_inj), sum(combined_map_rec)

# -----------------------------------------------------------------------------
# Outputs (FITS maps)
# -----------------------------------------------------------------------------
hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_combined_map_inj_"
    + str(np.round(particles_dip))
    + ".fits",
    combined_map_inj,
    overwrite=True,
)
hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_combined_map_rec_"
    + str(np.round(particles_dip))
    + ".fits",
    combined_map_rec,
    overwrite=True,
)

hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_combined_map_inj,
    overwrite=True,
)
hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_combined_map_rec,
    overwrite=True,
)

hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_1_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_map_inj_1,
    overwrite=True,
)
hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_1_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_map_rec_1,
    overwrite=True,
)

hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_2_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_map_inj_2,
    overwrite=True,
)
hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_2_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_map_rec_2,
    overwrite=True,
)

hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_3_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_map_inj_3,
    overwrite=True,
)
hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_3_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_map_rec_3,
    overwrite=True,
)

hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_4_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_map_inj_4,
    overwrite=True,
)
hp.write_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_4_"
    + str(np.round(particles_dip))
    + ".fits",
    Rot_map_rec_4,
    overwrite=True,
)
