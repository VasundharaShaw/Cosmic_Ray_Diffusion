#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Three-/Four-beam sky-map analysis (HEALPix + CRPropa).

Overview
--------
- Loads precomputed rotated injection/observation maps (FITS) and builds
  combined "beam" maps for different source weight combinations.
- Smooths maps with a top-hat beam and visualizes with Healpy.
- Computes dipole directions for map slices and compares to a reference region.

Data provenance
---------------
- The particle CSV read below was **generated by combining outputs from
  `Forward_pushing_particles.py`** (keep this note alongside the CSV in GitHub).

Notes
-----
- This is a direct conversion from a Jupyter workflow; no functional refactors
  have been made beyond adding comments/docstrings and removing notebook magics.
"""

# (notebook) %matplotlib inline  -> removed

import time
import crpropa
from crpropa import *
from scipy.stats import gennorm
import numpy as np
from scipy.special import sph_harm
import scipy.stats as stats
from joblib import Parallel, delayed
import multiprocessing
import logging
from astropy.io import fits

from astropy.coordinates import SkyCoord
import astropy.units as u

# Notebook display utilities (unused in plain script; kept for parity)
from IPython.display import HTML, Latex, Math, display  # noqa: F401

# Data analysis
import numpy as np  # duplicate import kept for parity with notebook
import pandas as pd
import os
import glob
from scipy.spatial.transform import Rotation as R
import warnings

warnings.filterwarnings("ignore")

# Create spherical-map
import healpy as hp

# Manage & convert astro coordinates
import astropy.units as u  # duplicate import kept for parity
import astropy.coordinates as Coord  # noqa: F401

# Plotting
import matplotlib
from matplotlib import rcParams  # noqa: F401
import matplotlib.image as mpimg  # noqa: F401

matplotlib.rcParams.update({"font.size": 35})
import matplotlib.pyplot as plt

sqrt = np.sqrt
import matplotlib.patches as mpatches  # noqa: F401
import cmcrameri.cm as cmc

from matplotlib.ticker import LogLocator  # noqa: F401

pi = np.pi

# ---------------------------------------------------------------------------
# Input particle table
# ---------------------------------------------------------------------------
# NOTE (provenance): This CSV was made by *combining* outputs from
# `Forward_pushing_particles.py`. Keep this note in your repo alongside the CSV.
data_hdf = pd.read_csv("Particles_7.7_Rin_30_Rout_2_Rin.csv")
com_data_np = data_hdf.to_numpy()
data_len = len(com_data_np)

# Used by top_hat_beam() to define theta grid length (mirrors notebook behavior)
lats_arr = np.zeros(len(com_data_np))


def top_hat_beam(radius, lmax):
    """
    Return spherical-harmonic window (b_l) for a top-hat beam.

    Parameters
    ----------
    radius : float
        Beam radius (radians).
    lmax : int
        Maximum multipole for the window function.

    Returns
    -------
    np.ndarray
        b_l coefficients up to lmax.
    """
    b = np.linspace(0.0, np.pi, len(lats_arr))
    bw = np.where(abs(b) <= radius, 1, 0)
    # Beam in spherical-harmonics space
    return hp.sphtfunc.beam2bl(bw, b, lmax=lmax)


def LoadSmoothedMap(hp_map, radius_deg, nside):
    """
    Smooth a HEALPix map with a top-hat beam of given radius.

    Parameters
    ----------
    hp_map : np.ndarray
        Input HEALPix map.
    radius_deg : float
        Top-hat radius in degrees.
    nside : int
        HEALPix nside (used here as lmax when building the top-hat window).

    Returns
    -------
    np.ndarray
        Smoothed map divided by beam solid angle.
    """
    radius = np.radians(radius_deg)
    solid_angle = 2.0 * np.pi * (1.0 - np.cos(radius))
    return hp.smoothing(hp_map, beam_window=top_hat_beam(radius, nside), verbose=False) / solid_angle


def MapToHealpyCoord(galCoord, l, b):
    """
    Convert (l, b) or (RA, Dec) into Healpy (phi, theta).

    Parameters
    ----------
    galCoord : bool
        If True, inputs are Galactic (l, b). If False, inputs are Equatorial (RA, Dec).
    l : array-like
        Longitude-like angle (radians).
    b : array-like
        Latitude-like angle (radians).

    Returns
    -------
    (phi, theta) : tuple of array-like
        Healpy azimuth and polar angles (radians).
    """
    theta = np.pi / 2 - b
    phi = l
    if not galCoord:  # Equatorial: shift by π to project to [0, 2π]
        phi -= np.pi
    return phi, theta


def HealpyCoordToMap(galCoord, phi, theta):
    """
    Convert Healpy (phi, theta) back to (l, b) or (RA, Dec).

    Parameters
    ----------
    galCoord : bool
        If True, return Galactic (l, b). If False, return Equatorial (RA, Dec).
    phi : array-like
        Healpy azimuth angle (radians).
    theta : array-like
        Healpy polar angle (radians).

    Returns
    -------
    (l, b) : tuple of array-like
        Longitude-like and latitude-like angles (radians).
    """
    b = np.pi / 2 - theta
    l = phi
    if not galCoord:  # Equatorial: l+π projected into [0, 2π]
        l = np.where(l < np.pi, l + np.pi, l - np.pi)
    return l, b


def LoadShapedData(galCoord=False, Emin=8.5):
    """
    Example of coordinate conversion + energy cut (requires a `data` frame with
    columns sd_ra, sd_dec, sd_l, sd_b, sd_energy).

    Parameters
    ----------
    galCoord : bool, optional
        Use Galactic if True, Equatorial if False. Default False.
    Emin : float, optional
        Minimum energy filter (EeV). Default 8.5.

    Returns
    -------
    pandas.DataFrame
        Columns: 'phi', 'theta' for events passing the energy cut.

    Notes
    -----
    This function references a `data` variable that is not defined elsewhere in
    this script; it is kept for parity with the original notebook.
    """
    coords = MapToHealpyCoord(
        galCoord,
        np.radians(data.sd_l if galCoord else data.sd_ra),  # noqa: F821
        np.radians(data.sd_b if galCoord else data.sd_dec),  # noqa: F821
    )
    unmasked = data.sd_energy > Emin  # noqa: F821
    dataset = pd.DataFrame(dict(zip(["phi", "theta"], coords)))[unmasked]
    return dataset


def LoadCountMap(dataset, nside):
    """
    Build a count map from event coordinates.

    Parameters
    ----------
    dataset : pandas.DataFrame
        Must contain columns 'theta' and 'phi' (radians).
    nside : int
        HEALPix nside.

    Returns
    -------
    np.ndarray
        HEALPix count map at the requested nside.
    """
    index = hp.ang2pix(nside, np.array(dataset.theta), np.array(dataset.phi))
    npix = hp.nside2npix(nside)
    count_map = np.histogram(index, bins=np.arange(npix + 1))[0]
    return count_map


# ---------------------------------------------------------------------------
# HEALPix base
# ---------------------------------------------------------------------------
nside = 32
npix = hp.nside2npix(nside)

# ---------------------------------------------------------------------------
# Load pre-rotated maps (Cen A, NGC 253, M31, M82)
# ---------------------------------------------------------------------------
Rot_map_inj_cenA = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_1_150180.fits"
)
Rot_map_rec_cenA = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_1_150180.fits"
)

Rot_map_inj_ngc253 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_2_150180.fits"
)
Rot_map_rec_ngc253 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_2_150180.fits"
)

Rot_map_inj_m31 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_3_150180.fits"
)
Rot_map_rec_m31 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_3_150180.fits"
)

Rot_map_inj_m82 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_4_150180.fits"
)
Rot_map_rec_m82 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_4_150180.fits"
)

# ---------------------------------------------------------------------------
# Weight grids and arrays for dipole exploration
# ---------------------------------------------------------------------------
ll, mm, nn, oo = 10, 10, 10, 10
norm_val = np.sqrt(4 * 10**2)
ll_val = np.zeros((ll, mm, nn, oo))
mm_val = np.zeros((ll, mm, nn, oo))
nn_val = np.zeros((ll, mm, nn, oo))
oo_val = np.zeros((ll, mm, nn, oo))

new_dip_lon = np.zeros((ll, mm, nn, oo))
new_dip_lat = np.zeros((ll, mm, nn, oo))

val_cenA = np.zeros((ll, mm, nn, oo))
val_ngc253 = np.zeros((ll, mm, nn, oo))
val_m31 = np.zeros((ll, mm, nn, oo))
val_m82 = np.zeros((ll, mm, nn, oo))

# %%time  (notebook timing magic removed)
# Reference dipole (Auger, converted to Galactic)
center_lon = 245.035
center_lat = -20.303
center_lon_rad = np.radians(center_lon)
center_lat_rad = np.radians(center_lat)

distance = np.zeros((ll, mm, nn, oo))

num = np.sqrt(ll**2 + mm**2 + nn**2 + oo**2)  # noqa: F841

# Sweep all weight combinations (example: set val_* to indices l, m, n, o)
for l in range(ll):
    for m in range(mm):
        for n in range(nn):
            for o in range(oo):
                # Example weights; adjust to your logic as needed
                val_cenA[l, m, n, o] = l  # / norm_val
                val_ngc253[l, m, n, o] = m  # / norm_val
                val_m31[l, m, n, o] = n  # / norm_val
                val_m82[l, m, n, o] = o  # / norm_val

                # Build weighted observed-map slice
                map_slice = (
                    Rot_map_rec_cenA * val_cenA[l, m, n, o]
                    + Rot_map_rec_ngc253 * val_ngc253[l, m, n, o]
                    + Rot_map_rec_m31 * val_m31[l, m, n, o]
                    + Rot_map_rec_m82 * val_m82[l, m, n, o]
                )

                # Dipole vector
                dip_vec = hp.fit_dipole(map_slice)[1]

                # Dipole lon/lat
                new_dip_lon[l, m, n, o], new_dip_lat[l, m, n, o] = hp.vec2ang(dip_vec, lonlat=True)

                # Angular separation from reference (degrees)
                new_dip_lon_rad = np.radians(new_dip_lon[l, m, n, o])
                new_dip_lat_rad = np.radians(new_dip_lat[l, m, n, o])
                distance[l, m, n, o] = np.degrees(
                    np.arccos(
                        np.sin(center_lat_rad) * np.sin(new_dip_lat_rad)
                        + np.cos(center_lat_rad)
                        * np.cos(new_dip_lat_rad)
                        * np.cos(new_dip_lon_rad - center_lon_rad)
                    )
                )

                # Record indices
                ll_val[l, m, n, o] = l
                mm_val[l, m, n, o] = m
                nn_val[l, m, n, o] = n
                oo_val[l, m, n, o] = o

# Flatten into table
combined_results = np.column_stack(
    (
        ll_val.flatten(),
        mm_val.flatten(),
        nn_val.flatten(),
        oo_val.flatten(),
        new_dip_lon.flatten(),
        new_dip_lat.flatten(),
        distance.flatten(),
    )
)

# Load previously saved results for visualization/search (skip the first two header rows)
data = np.loadtxt(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/new_dip_coordinates_2025_4beams_with_distances.txt",
    skiprows=2,
)

# Example: convert an equatorial coordinate (RA, Dec) to Galactic for plotting a search circle
ra = 97 * u.deg
dec = -37 * u.deg
coord = SkyCoord(ra=ra, dec=dec, frame="icrs")
galactic_coord = coord.galactic
galactic_lon_dip = galactic_coord.l.deg
galactic_lat_dip = galactic_coord.b.deg

# Circle center and radius
center_lon = galactic_lon_dip
center_lat = galactic_lat_dip
print(f"Center lon = {center_lon:.3f} Center lat = {center_lat:.3f}")
search_radius = 12
print()

# Pull columns
l_vals, m_vals, n_vals, o_vals = data[:, 0], data[:, 1], data[:, 2], data[:, 3]
lons = data[:, 4]
lats = data[:, 5]
distance = data[:, 6]

# Report best match by distance
print(
    f"minimum distance = {min(distance):.3e}, "
    f"l = {l_vals[np.where(distance == min(distance))]}, "
    f"m = {m_vals[np.where(distance == min(distance))]}, "
    f"n = {n_vals[np.where(distance == min(distance))]} , "
    f"o = {o_vals[np.where(distance == min(distance))]}, "
    f"lon = {lons[np.where(distance == min(distance))]}, "
    f"lat = {lats[np.where(distance == min(distance))]}, "
)

# ---------------------------------------------------------------------------
# Compose a 3-beam injected and observed map with chosen weights
# ---------------------------------------------------------------------------
val_cenA = 5
val_ngc253 = 6
val_m31 = 0
val_m82 = 6

Rot_map_inj = (
    Rot_map_inj_cenA * val_cenA
    + Rot_map_inj_ngc253 * val_ngc253
    + Rot_map_inj_m31 * val_m31
    + Rot_map_inj_m82 * val_m82
)
Rot_map_dip = (
    Rot_map_rec_cenA * val_cenA
    + Rot_map_rec_ngc253 * val_ngc253
    + Rot_map_rec_m31 * val_m31
    + Rot_map_rec_m82 * val_m82
)

matplotlib.rcParams.update({"font.size": 30})
radius_deg, nside = 10, 512
smooth_map_1_2 = LoadSmoothedMap(Rot_map_inj, radius_deg, nside)  # injected map (smoothed)

# (Re-)load maps (as in the notebook; kept verbatim)
Rot_map_inj_cenA = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_1_150180.fits"
)
Rot_map_rec_cenA = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_1_150180.fits"
)
Rot_map_inj_ngc253 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_2_150180.fits"
)
Rot_map_rec_ngc253 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_2_150180.fits"
)
Rot_map_inj_m31 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_3_150180.fits"
)
Rot_map_rec_m31 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_3_150180.fits"
)
Rot_map_inj_m82 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_4_150180.fits"
)
Rot_map_rec_m82 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_4_150180.fits"
)

# Plot injected 3-beam map (normalized by peak after monopole removal)
fig = plt.figure(figsize=(20.0, 20.0 / (3 / 2)))
norm_map_3beams = max(smooth_map_1_2 - hp.fit_monopole(smooth_map_1_2))
hp.mollview(
    (smooth_map_1_2 - hp.fit_monopole(smooth_map_1_2)) / norm_map_3beams,
    cmap="cmc.vik",  # NOTE: if this fails, use cmap=cmc.vik (object) instead of string
    title="Three beams injected map",
    min=0,
    max=1,
)
hp.graticule(linestyle="-", color="black")
for line in plt.gca().get_lines():
    line.set_linewidth(2.0)
plt.tight_layout(rect=[0, 0, 0.8, 1])
plt.savefig("3Beam_Combi_Skymap_Injec_Revised_a.png", bbox_inches="tight")
plt.show()

# Repeat with 45° smoothing radius
val_cenA = 5
val_ngc253 = 6
val_m31 = 0
val_m82 = 6

Rot_map_inj = (
    Rot_map_inj_cenA * val_cenA
    + Rot_map_inj_ngc253 * val_ngc253
    + Rot_map_inj_m31 * val_m31
    + Rot_map_inj_m82 * val_m82
)
Rot_map_dip = (
    Rot_map_rec_cenA * val_cenA
    + Rot_map_rec_ngc253 * val_ngc253
    + Rot_map_rec_m31 * val_m31
    + Rot_map_rec_m82 * val_m82
)

matplotlib.rcParams.update({"font.size": 30})
radius_deg, nside = 45, 512
smooth_map_1_2 = LoadSmoothedMap(Rot_map_inj, radius_deg, nside)

# (Re-)load maps again (kept as in notebook)
Rot_map_inj_cenA = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_1_150180.fits"
)
Rot_map_rec_cenA = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_1_150180.fits"
)
Rot_map_inj_ngc253 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_2_150180.fits"
)
Rot_map_rec_ngc253 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_2_150180.fits"
)
Rot_map_inj_m31 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_3_150180.fits"
)
Rot_map_rec_m31 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_3_150180.fits"
)
Rot_map_inj_m82 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_inj_4_150180.fits"
)
Rot_map_rec_m82 = hp.read_map(
    "Beam_case_2025_Rin_30_Rout_Rin_plus_1/4Beams_10deg_rot_combined_map_rec_4_150180.fits"
)

fig = plt.figure(figsize=(20.0, 20.0 / (3 / 2)))
norm_map_3beams = max(smooth_map_1_2 - hp.fit_monopole(smooth_map_1_2))
hp.mollview(
    (smooth_map_1_2 - hp.fit_monopole(smooth_map_1_2)) / norm_map_3beams,
    cmap="cmc.vik",
    title="Three beams injected map",
    min=0,
    max=1,
)
hp.graticule(linestyle="-", color="black")
for line in plt.gca().get_lines():
    line.set_linewidth(2.0)
plt.tight_layout(rect=[0, 0, 0.8, 1])
plt.savefig("3Beam_Combi_Skymap_Injec_Revised_b.png", bbox_inches="tight")
plt.show()

# ---------------------------------------------------------------------------
# Observed map for the same weights; draw PAO region and dipole marker
# ---------------------------------------------------------------------------
val_cenA = 5
val_ngc253 = 6
val_m31 = 0
val_m82 = 6

Rot_map_inj = (
    Rot_map_inj_cenA * val_cenA
    + Rot_map_inj_ngc253 * val_ngc253
    + Rot_map_inj_m31 * val_m31
    + Rot_map_inj_m82 * val_m82
)
Rot_map_dip = (
    Rot_map_rec_cenA * val_cenA
    + Rot_map_rec_ngc253 * val_ngc253
    + Rot_map_rec_m31 * val_m31
    + Rot_map_rec_m82 * val_m82
)

fig = plt.figure(figsize=(20.0, 20.0 / (3 / 2)))
norm_sources = np.sqrt(val_cenA**2 + val_ngc253**2 + val_m31**2 + val_m82**2)

# Dipole direction of observed map
dip_vec = hp.fit_dipole(Rot_map_dip)[1]
xx, yy, zz = dip_vec[0], dip_vec[1], dip_vec[2]
rr = np.sqrt(xx**2 + yy**2 + zz**2)  # noqa: F841

new_dip_lon, new_dip_lat = hp.vec2ang(dip_vec, lonlat=True)
print("Lon = ", new_dip_lon, "Lat = ", new_dip_lat)

radius_deg, nside = 45, 512
smooth_map_1_1 = LoadSmoothedMap(Rot_map_dip, radius_deg, nside)

hp.mollview(
    (smooth_map_1_1 - hp.fit_monopole(smooth_map_1_1)) / norm_map_3beams,
    cmap="cmc.vik",
    sub=(2, 2, 2),
    title=r"Three beam observed map",
    min=-0.001,
    max=0.001,
)
hp.graticule(linestyle="-", color="black")
for line in plt.gca().get_lines():
    line.set_linewidth(2)

new_dip_lon_val, new_dip_lat_val = new_dip_lon[0], new_dip_lat[0]
hp.projscatter(new_dip_lon_val, new_dip_lat_val, lonlat=True, marker="*", color="black", s=200)
plt.text(1.0, -0.50, r"Dipole", color="black", ha="center", fontsize=22, fontweight="bold")
plt.text(1.0, -0.61, r"direction", color="black", ha="center", fontsize=22, fontweight="bold")

# Draw PAO region ellipse (approx)
lon_radius = 10  # deg
lat_radius = 10  # deg
num_points = 100
theta = np.linspace(0, 2 * np.pi, num_points)
lon_circle = center_lon + lon_radius * np.cos(theta)
lat_circle = center_lat + lat_radius * np.sin(theta)
hp.projplot(lon_circle, lat_circle, lonlat=True, color="blue", lw=2.4)
plt.text(1.0, -0.13, r"PAO > 8 EeV", color="blue", fontsize=22, fontweight="bold")

plt.savefig("3Beam_Combi_Skymap_Obs_Revised.png", bbox_inches="tight")
plt.tight_layout(rect=[0, 0, 0.8, 1])

# ---------------------------------------------------------------------------
# Single-beam (Cen A) example plots
# ---------------------------------------------------------------------------
matplotlib.rcParams.update({"font.size": 30})

fig = plt.figure(figsize=(20.0, 20.0 / (3 / 2)))
val_cenA = 9
val_ngc253 = 10  # not used in 1-beam block below
val_m31 = 0
val_m82 = 10     # not used in 1-beam block below

Rot_map_inj = Rot_map_inj_cenA * val_cenA
Rot_map_dip = Rot_map_rec_cenA * val_cenA

dip_vec = hp.fit_dipole(Rot_map_dip)[1]
xx, yy, zz = dip_vec[0], dip_vec[1], dip_vec[2]
rr = np.sqrt(xx**2 + yy**2 + zz**2)  # noqa: F841

new_dip_lon, new_dip_lat = hp.vec2ang(dip_vec, lonlat=True)
print("Lon = ", new_dip_lon, "Lat = ", new_dip_lat)

radius_deg, nside = 10, 512
smooth_map_1_2 = LoadSmoothedMap(Rot_map_inj, radius_deg, nside)  # injection map
radius_deg, nside = 45, 512
smooth_map_1_1 = LoadSmoothedMap(Rot_map_dip, radius_deg, nside)

norm_map_1beam = max(smooth_map_1_2 - hp.fit_monopole(smooth_map_1_2))
hp.mollview(
    (smooth_map_1_2 - hp.fit_monopole(smooth_map_1_2)) / norm_map_1beam,
    cmap="cmc.vik",
    title="Single beam injected map",
    min=0,
    max=1,
)
hp.graticule(linestyle="-", color="black")
for line in plt.gca().get_lines():
    line.set_linewidth(2.0)
plt.tight_layout()
plt.savefig("1Beam_Revised_a.png", bbox_inches="tight")

# Repeat single-beam injected map with 45° smoothing (as in notebook)
matplotlib.rcParams.update({"font.size": 30})
fig = plt.figure(figsize=(20.0, 20.0 / (3 / 2)))

val_cenA = 9
val_ngc253 = 10
val_m31 = 0
val_m82 = 10

Rot_map_inj = Rot_map_inj_cenA * val_cenA
Rot_map_dip = Rot_map_rec_cenA * val_cenA

dip_vec = hp.fit_dipole(Rot_map_dip)[1]
xx, yy, zz = dip_vec[0], dip_vec[1], dip_vec[2]
rr = np.sqrt(xx**2 + yy**2 + zz**2)  # noqa: F841
new_dip_lon, new_dip_lat = hp.vec2ang(dip_vec, lonlat=True)
print("Lon = ", new_dip_lon, "Lat = ", new_dip_lat)

radius_deg, nside = 45, 512
smooth_map_1_2 = LoadSmoothedMap(Rot_map_inj, radius_deg, nside)
radius_deg, nside = 45, 512
smooth_map_1_1 = LoadSmoothedMap(Rot_map_dip, radius_deg, nside)

norm_map_1beam = max(smooth_map_1_2 - hp.fit_monopole(smooth_map_1_2))
hp.mollview(
    (smooth_map_1_2 - hp.fit_monopole(smooth_map_1_2)) / norm_map_1beam,
    cmap="cmc.vik",
    title="Single beam injected map",
    min=0,
    max=1,
)
hp.graticule(linestyle="-", color="black")
for line in plt.gca().get_lines():
    line.set_linewidth(2.0)
plt.tight_layout()
plt.savefig("1Beam_Revised_b.png", bbox_inches="tight")

fig = plt.figure(figsize=(20.0, 20.0 / (3 / 2)))
hp.mollview(
    (smooth_map_1_1 - hp.fit_monopole(smooth_map_1_1)) / norm_map_1beam,
    cmap="cmc.vik",
    norm="hist",
    min=-0.13,
    max=0.13,
    title=r"Single beam observed map",
)
hp.graticule(linestyle="-", color="black")
for line in plt.gca().get_lines():
    line.set_linewidth(2.0)

# Optionally draw axes
hp.projplot([0, 360], [0, 0], lonlat=True, color="black", linewidth=8)
hp.projplot([0, 0], [-90, 90], lonlat=True, color="black", linewidth=8)

# Example region ellipse (values from above if desired)
lon_radius = 8
lat_radius = 9
num_points = 100
theta = np.linspace(0, 2 * np.pi, num_points)
lon_circle = center_lon + lon_radius * np.cos(theta)
lat_circle = center_lat + lat_radius * np.sin(theta)
# hp.projplot(lon_circle, lat_circle, lonlat=True, color="blue", lw=2)

plt.tight_layout()
plt.savefig("1Beam_7.7_Obs.png", bbox_inches="tight")
# Done.

